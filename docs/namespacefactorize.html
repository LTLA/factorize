<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>factorize: factorize Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">factorize
   </div>
   <div id="projectbrief">Create factors from categorical variables</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">factorize Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Create factors from categorical variables.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a18cfb52c8107a752fc47fccc09d278b0" id="r_a18cfb52c8107a752fc47fccc09d278b0"><td class="memTemplParams" colspan="2">template&lt;typename Input_ , typename Code_ &gt; </td></tr>
<tr class="memitem:a18cfb52c8107a752fc47fccc09d278b0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Input_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a18cfb52c8107a752fc47fccc09d278b0">combine_to_factor</a> (const std::size_t n, const std::vector&lt; const Input_ * &gt; &amp;inputs, Code_ *const codes)</td></tr>
<tr class="separator:a18cfb52c8107a752fc47fccc09d278b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f94244ddeea0d7612e59b391bd82a3" id="r_a62f94244ddeea0d7612e59b391bd82a3"><td class="memTemplParams" colspan="2">template&lt;typename Input_ , typename Number_ , typename Code_ &gt; </td></tr>
<tr class="memitem:a62f94244ddeea0d7612e59b391bd82a3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Input_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62f94244ddeea0d7612e59b391bd82a3">combine_to_factor_unused</a> (const std::size_t n, const std::vector&lt; std::pair&lt; const Input_ *, Number_ &gt; &gt; &amp;inputs, Code_ *const codes)</td></tr>
<tr class="separator:a62f94244ddeea0d7612e59b391bd82a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd6c4e3624487dc86c0905ccdd1cce2" id="r_a0bd6c4e3624487dc86c0905ccdd1cce2"><td class="memTemplParams" colspan="2">template&lt;typename Input_ , typename Code_ &gt; </td></tr>
<tr class="memitem:a0bd6c4e3624487dc86c0905ccdd1cce2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Input_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0bd6c4e3624487dc86c0905ccdd1cce2">create_factor</a> (const std::size_t n, const Input_ *const input, Code_ *const codes)</td></tr>
<tr class="separator:a0bd6c4e3624487dc86c0905ccdd1cce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Create factors from categorical variables. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a18cfb52c8107a752fc47fccc09d278b0" name="a18cfb52c8107a752fc47fccc09d278b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cfb52c8107a752fc47fccc09d278b0">&#9670;&#160;</a></span>combine_to_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input_ , typename Code_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; Input_ &gt; &gt; factorize::combine_to_factor </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Input_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Code_ *const</td>          <td class="paramname"><span class="paramname"><em>codes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_</td><td>Type of the categorical variables to be combined. Any type may be used here as long as it implements the comparison operators. </td></tr>
    <tr><td class="paramname">Code_</td><td>Integer type of the codes of the combined factor. This should be large enough to hold the number of unique combinations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations (i.e., cells). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputs</td><td>Vector of pointers to arrays of length <code>n</code>, each containing a different categorical variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codes</td><td>Pointer to an array of length <code>n</code> in which the codes of the combined factor are to be stored. On output, the code for observation <code>i</code> refers to the factor level defined by indexing into the inner vectors of the output vector, i.e., for <code>j := codes[i]</code>, the factor level is defined by the combination <code>(output[0][j], output[1][j], ...)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of vectors containing the levels of the combined factor. Each inner vector corresponds to a variables in <code>inputs</code>, and all inner vectors have the same length. Corresponding entries of the inner vectors represent a level of the combined factor, in the form of a combination of values from the input variables, i.e., the first level is defined as <code>(output[0][0], output[1][0], ...)</code>, the second level is defined as <code>(output[0][1], output[1][1], ...)</code>, and so on. Each entry in <code>output[i]</code> is guaranteed to be a value in <code>inputs[i]</code>. Combinations are guaranteed to be unique and lexicographically sorted (i.e., by the value of the first variable, then the second, and so on). </dd></dl>

</div>
</div>
<a id="a62f94244ddeea0d7612e59b391bd82a3" name="a62f94244ddeea0d7612e59b391bd82a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f94244ddeea0d7612e59b391bd82a3">&#9670;&#160;</a></span>combine_to_factor_unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input_ , typename Number_ , typename Code_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; Input_ &gt; &gt; factorize::combine_to_factor_unused </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; const Input_ *, Number_ &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Code_ *const</td>          <td class="paramname"><span class="paramname"><em>codes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a variation of <code><a class="el" href="#a18cfb52c8107a752fc47fccc09d278b0">combine_to_factor()</a></code> that considers unobserved combinations of variables.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_</td><td>Factor type. Any type may be used here as long as it is comparable. </td></tr>
    <tr><td class="paramname">Number_</td><td>Integer type for the number of unique values in each variable. </td></tr>
    <tr><td class="paramname">Code_</td><td>Integer type for the combined factor. This should be large enough to hold the number of unique (possibly unused) combinations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations (i.e., cells). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputs</td><td>Vector of pairs, each of which corresponds to a categorical variable. The first element of the pair is a pointer to an array of length <code>n</code>, containing the values of the variable for each observation. The second element is the total number of unique values for this variable, which may be greater than the largest observed level. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codes</td><td>Pointer to an array of length <code>n</code> in which the codes of the combined factor are to be stored. On output, each entry determines the corresponding observation's combination of levels by indexing into the inner vectors of the returned object; see the argument of the same name in <code><a class="el" href="#a18cfb52c8107a752fc47fccc09d278b0">combine_to_factor()</a></code> for more details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of vectors containing all unique and sorted combinations of the input variables. This has the same structure as the output of <code><a class="el" href="#a18cfb52c8107a752fc47fccc09d278b0">combine_to_factor()</a></code>, with the only difference being that unobserved combinations are also reported. </dd></dl>

</div>
</div>
<a id="a0bd6c4e3624487dc86c0905ccdd1cce2" name="a0bd6c4e3624487dc86c0905ccdd1cce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd6c4e3624487dc86c0905ccdd1cce2">&#9670;&#160;</a></span>create_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input_ , typename Code_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Input_ &gt; factorize::create_factor </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Input_ *const</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Code_ *const</td>          <td class="paramname"><span class="paramname"><em>codes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a categorical variable into a factor. Factors are defined in a similar manner as in the R programming language, i.e., an array of integer codes, each of which reference into an array of unique levels.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_</td><td>Type of the categorical variable. Any type may be used here as long as it is hashable and has an equality operator. </td></tr>
    <tr><td class="paramname">Code_</td><td>Integer type for the output factor codes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array of length <code>n</code> containing the input categorical variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codes</td><td>Pointer to an array of length <code>n</code> in which the factor codes are to be stored. All values are integers in \([0, N)\) where \(N\) is the length of the output vector; all integers in this range are guaranteed to be present at least once in <code>cleaned</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the unique and sorted values of <code>input</code>, i.e., the factor levels. For any observation <code>i</code>, it is guaranteed that <code>output[codes[i]] == input[i]</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
